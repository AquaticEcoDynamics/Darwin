% /////// fv_calibrate_points_print ///////
%
% function fv_calibrate_points_print(C,varargin)
%
% Reads in the structure C generated by fv_calibrate_points and writes the
% information within to a .csv file. A file "fv_calibrate_points.csv" is written
% to the directory from which fv_calibrate_points_print.m was called. You
% can optionally specify the name of the output file.
%
% What you see in the plots generated by fv_calibrate_points is
% what is printed to the .csv files, ie. the conventions & units are the same.
%
% The matricees written to fv_calibrate_points.csv or your specified file are padded with NaN's
% where necessary. It is recommended you "replace all" the NaN's to empty
% cells.
%
% INPUTS:
%   C = structure generated by fv_calibrate_points.m
%
% OUTPUTS
%   fv_calibrate_points.csv
%
% Jesper Nielsen August 2013

function fv_calibrate_points_print(C,varargin)

% optional inputs
if length(varargin) == 1
    outfil = varargin{1};
else
    outfil = 'fv_calibrate_points.csv';
end

% -- cycle through model runs storing results in a single matrix
header_1 = {}; % model run / data file header
header_2 = {}; % point name header
header_3 = {}; % variable name header
out = [];
k = 1;

% model results
if isfield(C,'MOD')
    display('extracting model results ready for printing')
    % -- points from where results extracted
    points = fieldnames(C.MOD);
    np = length(points);
    % -- model runs from where results extracted
    runs = fieldnames(C.MOD.(points{1}));
    nr = length(runs);
    for aa = 1:nr
        r_name = runs{aa};
        header_1{k} = r_name;
        for bb = 1:np
            p_name = points{bb};
            header_2{k} = p_name;
            variables = fieldnames(C.MOD.(p_name).(r_name));
            nv = length(variables);
            % -- -- ensure 'ResTime' is the 1st variable
            [~,i] = ismember(variables,'ResTime');
            if i > 1
                variables{i} = [];
                variables = cat(1,'ResTime',variables);
            end
            for cc = 1:nv
                v_name = variables{cc};
                switch v_name
                    case 'ResTime'
                        if bb == 1
                            t = C.MOD.(p_name).(r_name).(v_name);
                            t = t - datenum('01/01/1900','dd/mm/yyyy') + 2; % matlab time to Excel time
                            nt = length(t);
                            header_3{k} = v_name;
                            k = k + 1;
                            tmp = t';
                        end
                    otherwise
                        options = fieldnames(C.MOD.(p_name).(r_name).(v_name));
                        no = length(options);
                        for dd = 1:no
                            o_name = options{dd};
                            header_3{k} = [v_name '_' o_name];
                            k = k + 1;
                            tmp = cat(2,tmp,C.MOD.(p_name).(r_name).(v_name).(o_name)');
                        end
                end
            end
        end
        % padding the matricees
        if isempty(out)
            out = tmp;
        else
            if nt > nt_old
                out(nt_old+1:nt,:) = NaN;
            else
                tmp(nt+1:nt_old,:) = NaN;
            end
            out = cat(2,out,tmp);
        end
        nt_old = size(out,1);
    end
end

% data values
if isfield(C,'DAT')
    display('extracting data values ready for printing')
    % -- points from where data extracted
    points = fieldnames(C.DAT);
    np = length(points);
    % -- data files from where data extracted
    dats = {};
    for aa = 1:np
    dats_tmp = fieldnames(C.DAT.(points{aa}));
    dats = cat(1,dats,dats_tmp);
    end
    dats = unique(dats);
    nd = length(dats);
    for aa = 1:nd
        d_name = dats{aa};
        header_1{k} = d_name;
        for bb = 1:np
            p_name = points{bb};
            dats_tmp = fieldnames(C.DAT.(p_name));
            if ~ismember(d_name,dats_tmp)
                continue
            end
            header_2{k} = p_name;
            variables = fieldnames(C.DAT.(p_name).(d_name));
            % remove coordinates
            i = ismember(variables,'coordinates');
            variables = variables(~i);
            nv = length(variables);
            % group variables with their respective time vectors
            for cc = 1:nv
                v_name = variables{cc};
                if ismember(v_name,C.variables) % what is in DAT is not necessarily what has been plotted
                    switch v_name
%                         case {'TIME_hydro';'TIME_wave';'TIME_sedi';'TIME_wind'};
                            % continue
                        case {'WVHT','WVPER','WVDIR'}
                            TMP.TIME_wave.(v_name) = C.DAT.(p_name).(d_name).(v_name);
                        case {'W10_mag','W10_dir','W10_x','W10_y'}
                            TMP.TIME_wind.(v_name) = C.DAT.(p_name).(d_name).(v_name);
                        case {'TSS','NTU'}
                            TMP.TIME_sedi.(v_name) = C.DAT.(p_name).(d_name).(v_name);
                        otherwise
                            TMP.TIME_hydro.(v_name) = C.DAT.(p_name).(d_name).(v_name);
                    end
                end
            end
            % build up matrix
            names = fieldnames(TMP);
            nn = length(names); % number of time variables
            for cc = 1:nn
                name = names{cc};
                variables = fieldnames(TMP.(name));
                nv = length(variables);
                t = C.DAT.(p_name).(d_name).(name);
                t = t - datenum('01/01/1900','dd/mm/yyyy') + 2;
                nt = length(t);
                if size(t,2) == nt
                    tmp = t';
                else
                    tmp = t;
                end
                header_3{k} = name;
                k = k + 1;
                for dd = 1:nv
                    v_name = variables{dd};
                    options = fieldnames(TMP.(name).(v_name));
                    no = length(options);
                    for ee = 1:no
                        o_name = options{ee};
                        if size(TMP.(name).(v_name).(o_name),1) == nt % data not always stored in correct format
                            tmp = cat(2,tmp,TMP.(name).(v_name).(o_name));
                        else
                            tmp = cat(2,tmp,TMP.(name).(v_name).(o_name)');
                        end
                        header_3{k} = [v_name '_' o_name];
                        k = k + 1;
                    end
                end
                % padding
                if isempty(out)
                    out = tmp;
                else
                    if nt > nt_old
                        out(nt_old+1:nt,:) = NaN;
                    else
                        tmp(nt+1:nt_old,:) = NaN;
                    end
                    out = cat(2,out,tmp);
                end
                nt_old = size(out,1);
            end
        end
    end
end
% header lines need to be this long
header_1{k-1} = [];
header_2{k-1} = [];

% write the .csv file
% -- delete existing file
if exist(outfil,'file')
    display(['hit enter to overwrite existing ' outfil ' file'])
    pause
    delete(outfil)
end
% -- write all info to file
display(['writing ' outfil])
[~,nc] = size(out);
fid = fopen(outfil,'w');
% -- -- header lines
fmat = ['%s' repmat(',%s',1,nc-1) '\n'];
fprintf(fid,fmat,header_1{:});
fprintf(fid,fmat,header_2{:});
fprintf(fid,fmat,header_3{:});
% fclose(fid);
% % -- -- bulk info, use dlmwrite to avoid including the NaN's
% for aa = 1:nc
%     tmp = out(:,aa);
%     i = find(~isnan(tmp),1,'last');
%     dlmwrite(outfil,tmp(1:i),'-append','roffset',2,'coffset',aa-1,'precision', 10)
% end

fmat = ['%f' repmat(',%f',1,nc-1) '\n'];
inc = [];
tic
nt = size(out,1);
for aa = 1:nt
    fprintf(fid,fmat,out(aa,:));
    inc = mytimer(aa,[1 nt],inc);
end
fclose(fid);

display('done & done :-)')

