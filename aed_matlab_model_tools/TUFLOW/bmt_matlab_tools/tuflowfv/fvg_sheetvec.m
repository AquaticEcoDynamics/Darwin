% FVG_SHEETVEC     visualise TUFLOW-FV model vector results in plan view
%
%   sheetvecObj = fvg_sheetvec(controlObj,resfil) adds a sheetvec object to the current axes.
%   No vectors appear until the variables property is set. controlObj is created
%   by the function fvgraphics.m and resfil is the cell-centre netcdf results
%   file generated by TUFLOW-FV.
%
%   sheetvecObj = fvg_sheetvec(controlObj,resfil,'PropertyName',PropertyValue,...) creates
%   a sheetvec object defined by the specified property name / property value
%   pairs. Default values are assigned to all unspecified properties.
%
%   Execute get(sheetvecObj), to see a list of the sheetvecObj's properties and
%   their current values.
%
%   Execute set(sheetvecObj,'PropertyName',PropertyValue) to change a
%   property of an existing sheetvecObj.
%
%
%   /-/-/-/-/-/-/-/-/ EXAMPLES /-/-/-/-/-/-/-/-/
%
%   (1): Create a sheetvecObj displaying the currents
%   controlObj = fvgraphics;
%   sheetvecObj = fvg_sheetvec(controlObj,'mymodel.nc','variables',{'V_x';'V_y'})
%
%   (2): Depth averaged 3D results over the bottom 2 metres
%   set(sheetvecObj,'ref','height','range',[0 2])
%
%   (3): Change the colors of the vectors to red
%   set(sheetvecObj,'vec_face_color','red')
%
%
%   /-/-/-/-/-/-/-/-/ PROPERTIES /-/-/-/-/-/-/-/-/
%
%   Type           ==> fvg_sheetvec
%
%   Resfil         ==> TUFLOW-FV cell-centre netcdf results file
%
%   Geofil         ==> TUFLOW-FV netcdf geometry file
%
%   ControlObj     ==> object created by fvgraphics.m with which the time to view results is set
%
%   ResObj         ==> object created by fvres_sheet.m with which results are processed and stored
%
%   PatchObj       ==> object created by patch.m with which results are displayed
%
%   PeerObj        ==> object created by axes.m which the patchObj exists within
%
%   Title_time     {off} | on ==> display the time as the peerObj's (axes) title
%
%   ListObj_up     ==> object created by addlistener.m which listens to updates in the results from the resObj
%
%   ListObj_ut     ==> object created by addlistener.m which listens to updates in the current time from the controlObj
%
%   ListObj_uvf    ==> object created by addlistener.m which listens for changes to the figure which affect the vectors
%
%   Variables      ==> vector variables to visualise
%
%   Expression     ==> string expression for customizing results
%
%   Ref            {sigma} | depth | height | elevation | top | bottom ==> how 3D results are depth averaged
%
%   Range          {[0 1]} | vector of length 2 ==> limits corresponding to ref for which 3D results are depth averaged over
%
%   VecScale       {50} ==> vector of magnitude 1 is vec_scale pixels long
%
%   VecGrid        {30} ==> spacing in pixels of vectors
%
%   VecShapeHead   {[0.15, 0.30, 1]} ==> [width, length, 1 when width and length scale on arrow length & 0 when fixed]
%
%   VecShapeTail   {[0, 1]} ==> [width, 1 when width scale on arrow length & 0 when fixed]
%
%   ZOffset        {0} ==> scalar elevation to plot all vectors / cones at
%
%   FaceColor      {ColorSpec} | none | flat ==> color of vector faces
%
%   EdgeColor      {ColorSpec} | none ==> color of vector edges
%
%   Cones          {false} | true ==> plot cones instead of arrows
%
%
% See also FVG_SHEET, FVG_CURTAIN & FVGRAPHICS
%
% http://tuflow.com/fvforum/index.php?/forum/16-matlab/
% http://fvwiki.tuflow.com/index.php?title=Depth_Averaging_Results
% http://fvwiki.tuflow.com/index.php?title=MATLAB_TUTORIAL
%
% Jesper Nielsen, Copyright BMT WBM


classdef (CaseInsensitiveProperties = true) fvg_sheetvec < fvg
    
    properties (Constant)
        Type = 'fvg_sheetvec';
    end
    properties
        VecScale = 50
        VecGrid = 30
        VecShapeHead = [0.15 0.30 1]
        VecShapeTail = [0 1]
        ZOffset = 0
        Transparency
        Cones = false
        ListObj_uvf
        %         listObj_uva
    end
    properties (Dependent)
        Ref = 'sigma'
        Range = [0 1]
    end
    properties (Hidden)
        node_n; node_x; node_y; node_xmin; node_xmax; node_ymin; node_ymax;
        vert_x; vert_y; vec_multi; points; ic2; fvgobj; data_x; data_y;
        daspect; faces; verts
    end
    
    methods
        % // constructor method //
        function obj = fvg_sheetvec(controlObj,resfil,varargin)
            % Pre-initialization — compute arguments for superclass constructor. Any code not using output argument (obj)
            h = fvres_sheet(resfil);
            
            % Object initialization — call superclass constructor before accessing object. You cannot conditionalize this statement
            obj@fvg(controlObj,resfil,h);
            
            % Post initialization — Operations related to the subclass, referencing and assigning to obj, calling class methods, passing onto functions etc.
            % -- define the mesh
            TMP = netcdf_get_var(obj.ResObj.Nci,'names',{'node_X','node_Y','cell_node','ResTime'});
            node_X = TMP.node_X;
            node_Y = TMP.node_Y;
            cell_node = TMP.cell_node;
            i = cell_node == 0;
            cell_node(i) = 1;
            obj.node_x = node_X(cell_node);
            obj.node_y = node_Y(cell_node);
            obj.node_x(i) = NaN;
            obj.node_y(i) = NaN;
            obj.node_xmin = mini(obj.node_x);
            obj.node_xmax = maxi(obj.node_x);
            obj.node_ymin = mini(obj.node_y);
            obj.node_ymax = maxi(obj.node_y);
            obj.node_n = sum(~i);
            
            set(obj.PatchObj,'FaceColor','k')
            
            % -- ear to the keyhole (the listeners not defined in fvg superclass)
            obj.ListObj_uvf = addlistener(obj.ControlObj,'update_vectors',@(src,evnt)respond_vectors(obj,src,evnt)); % panning, zooming & figure resizing requires indexing of vectors within cells to change
            %             obj.listObj_uva = addlistener(obj.peerObj,'Position','PostSet',@(src,evnt)respond_vectors(obj,src,evnt));     Have not got this to work nicely yet
            
            % -- gridded vectors, cell indexing, vector scaling
            [obj.points,obj.ic2,obj.vec_multi] = fvsheet_vec_grid(obj); % why is this here ?
            
            % -- ensure vectors initialise for the time_current (also brings the stat variable into the resObj which is a condition in updatepatchdata)
            tmp = get(obj.ControlObj,'TimeCurrent');
            set(obj.ResObj,'TimeCurrent',tmp) % updatepatchdata won't do anything until a Variables has been set
            
            % -- property / value pairs (optional inputs)
            noi = length(varargin);
            if mod(noi,2) ~= 0
                error('expecting optional inputs as property / value pairs')
            end
            for aa = 1:2:noi
                set(obj,varargin{aa},varargin{aa+1})
            end
        end
        
        % // set methods //
        function set.Ref(obj,val)
            set(obj.ResObj,'Ref',val)
        end
        function set.Range(obj,val)
            set(obj.ResObj,'Range',val)
        end
        function set.VecScale(obj,val)
            obj.VecScale = val;
            [obj.points,obj.ic2,obj.vec_multi] = fvsheet_vec_grid(obj);
            updatepatchdata(obj)
        end
        function set.VecGrid(obj,val)
            obj.VecGrid = val;
            [obj.points,obj.ic2,obj.vec_multi] = fvsheet_vec_grid(obj);
            updatepatchdata(obj)
        end
        function set.VecShapeHead(obj,val)
            if obj.Cones
                display('VecShapeHead property is irrelevant when plotting cones')
            else
                obj.VecShapeHead = val;
                updatepatchdata(obj);
            end
        end
        function set.VecShapeTail(obj,val)
            if obj.Cones
                display('VecShapeTail property is irrelevant when plotting cones')
            else
                obj.VecShapeTail = val;
                updatepatchdata(obj);
            end
        end
        function set.Transparency(obj,val)
            display('Transparency property is not yet supported for fvg_sheetvec')
            return
%             if islogical(val)
%                 obj.Transparency = val;
%                 if val
%                     updatepatchdata(obj)
%                 else
%                     set(obj.PatchObj,'FaceAlpha',1)
%                 end
%             else
%                 error('expecting logical value for Transparency')
%             end
        end
        function set.ZOffset(obj,val)
            if isscalar(val)
                obj.ZOffset = val;
                if ~obj.Cones
                    tmp = get(obj.PatchObj,'XData');
                    tmp(:) = val;
                    set(obj.PatchObj,'ZData',tmp) % this means ZData is not set everytime updatepatchdata is called
                else
                    updatepatchdata(obj) % cones uses ZOffset as an input
                end
            else
                error('expecting scalar value for property vec_elevation')
            end
        end
        function set.Cones(obj,val)
            if islogical(val)
                obj.Cones = val;
                set(obj.PatchObj,'EdgeColor','none')
                updatepatchdata(obj)
            else
                error('expecting logical value for property Cones')
            end
        end
        % // get methods //
        function val = get.Ref(obj)
            val = get(obj.ResObj,'Ref'); % when ref property set and nothing happens in the ref2Dobj you don't show the property that didn't work
        end
        function val = get.Range(obj)
            val = get(obj.ResObj,'Range'); % ensure the property of what you see is the same as the property of the res2Dobj
        end
        function val = get.VecShapeHead(obj)
            if obj.Cones
                val = [];
            else
                val = obj.VecShapeHead;
            end
        end
        function val = get.VecShapeTail(obj)
            if obj.Cones
                val = [];
            else
                val = obj.VecShapeTail;
            end
        end
        % // respond to notifications (additional to those in fvg superclass) //
        function respond_vectors(obj,~,~)
            %             if ~isempty(obj.fvgobj.axes_update) && obj.fvgobj.axes_update == obj.peerObj
            [obj.points, obj.ic2, obj.vec_multi, obj.daspect] = fvsheet_vec_grid(obj);
            updatepatchdata(obj)
            %             end
        end
        function updatepatchdata(obj) % override that in superclass
            %             vars = get(obj,'Variables');
            vars = fieldnames(obj.ResObj.ResultsCell); % Customized variable names are also used for customized results
            vars = setxor(vars,'stat');
            if ~isempty(vars) && ~isempty(obj.points)
                if length(vars) > 2
                    vars = vars(2:3); % sharing a resObj with fvg_sheet
                elseif length(vars) < 2
                    display('cannot visualise scalar results with vectors')
                    return
                end
                obj.data_x = obj.ResObj.ResultsCell.(vars{1});
                obj.data_y = obj.ResObj.ResultsCell.(vars{2});
                if obj.Cones
                    [obj.faces, obj.verts] = cones(obj.data_x(obj.ic2),obj.data_y(obj.ic2),[],obj.points(:,1),obj.points(:,2),obj.ZOffset,'scale',obj.vec_multi,'daspect',obj.daspect);
                    set(obj.PatchObj,'faces',obj.faces,'vertices',obj.verts)
                    if strcmpi(obj.FaceColor,'flat')
                        mag = hypot(obj.data_x(obj.ic2),obj.data_y(obj.ic2));
                        fvc = repmat(mag',26,1);
                        set(obj.PatchObj,'FaceVertexCData',fvc(:)) % Z components not yet implemented
                    end
                else
                    [obj.vert_x, obj.vert_y] = arrow2(obj.data_x(obj.ic2),obj.data_y(obj.ic2),obj.points(:,1),obj.points(:,2),'scale',obj.vec_multi,'shape_head',obj.VecShapeHead,'shape_tail',obj.VecShapeTail);
                    set(obj.PatchObj,'XData',obj.vert_x,'YData',obj.vert_y)
                    if strcmpi(obj.FaceColor,'flat')
                        set(obj.PatchObj,'CData',hypot(obj.data_x(obj.ic2),obj.data_y(obj.ic2)))
                    end
                end
                if strcmp(obj.TitleTime,'on')
                    tstr = datestr(obj.ResObj.TimeCurrent,'dd-mmm-yyyy HH:MM:SS');
                    set(get(obj.PeerObj,'Title'),'String',tstr)
                end
            end
        end
    end
end

% // subfunctions //




