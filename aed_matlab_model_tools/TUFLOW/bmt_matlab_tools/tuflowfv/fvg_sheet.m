% FVG_SHEET     visualise TUFLOW-FV model scalar results in plan view
%
%   sheetObj = fvg_sheet(controlObj,resfil) adds a sheet object displaying
%   the model's cell elevations to the current axes. controlObj is created
%   by the function fvgraphics.m and resfil is the cell-centre netcdf results
%   file generated by TUFLOW-FV.
%
%   sheetObj = fvg_sheet(controlObj,resfil,'PropertyName',PropertyValue,...) creates
%   a sheet object defined by the specified property name / property value
%   pairs. Default values are assigned to all unspecified properties.
%
%   Execute get(sheetObj), to see a list of the sheetObj's properties and
%   their current values.
%
%   Execute set(sheetObj,'PropertyName',PropertyValue) to change a
%   property of an existing sheetObj.
%
%
%   /-/-/-/-/-/-/-/-/ EXAMPLES /-/-/-/-/-/-/-/-/
%
%   (1): Create a sheetObj displaying the salinity
%   controlObj = fvgraphics;
%   sheetObj = fvg_sheet(controlObj,'mymodel.nc','variables','SAL')
%
%   (2): Depth averaged 3D results over the bottom 2 metres
%   set(sheetObj,'ref','height','range',[0 2])
%
%
%   /-/-/-/-/-/-/-/-/ PROPERTIES /-/-/-/-/-/-/-/-/
%
%   Type           ==> fvg_sheet
%
%   Resfil         ==> TUFLOW-FV cell-centre netcdf results file
%
%   Geofil         ==> TUFLOW-FV netcdf geometry file
%
%   ControlObj     ==> object created by fvgraphics.m with which the timestep to view results is set
%
%   ResObj         ==> object created by fvres_sheet.m with which results are processed and stored
%
%   PatchObj       ==> object created by patch.m with which results are displayed
%
%   PeerObj        ==> object created by axes.m which the PatchObj exists within
%
%   ListObj_up     ==> object created by addlistener.m which listens to updates in the results from the ResObj
%
%   ListObj_ut     ==> object created by addlistener.m which listens to updates in the current time from the ControlObj
%
%   Variables      ==> variable to visualise, when 2 variables specified the magnitude is computed and displayed
%
%   Expression     ==> string expression for customizing results
%
%   Ref            {sigma} | depth | height | elevation | top | bottom ==> how 3D results are depth averaged
%
%   Range          {[0 1]} | vector of length 2 ==> limits corresponding to Ref to depth average results over
%
%   BedRef         {[]} | integer ==> sediment fraction to visualise within bed variables, [] indicates the sum of all fractions
%
%   BedFrac        {false} | true ==> visualise whole value for fraction specified in BedRef or fraction of total
%
%   FaceColor      {ColorSpec} | none | flat | interp ==> color of cell faces
%
%   EdgeColor      {ColorSpec} | none ==> color of cell edges
%
%   Transparency   {false} | true ==> scale the transparency on the scalar value of the variable being displayed
%
%   Vectors        {off} | on ==> display current vectors over the sheetObj
%
%   VectorObj      ==> object created by fvg_sheetvec.m which has the same Ref and Range properties as the sheetObj
%
%   ZOffset        {0} ==> scalar elevation to plot results at
%
%   TitleTime     {off} | on ==> display the time as the PeerObj's (axes) title
%
%
% See also FVG_SHEETVEC, FVG_CURTAIN & FVGRAPHICS
%
% http://tuflow.com/fvforum/index.php?/forum/16-matlab/
% http://fvwiki.tuflow.com/index.php?title=Depth_Averaging_Results
% http://fvwiki.tuflow.com/index.php?title=MATLAB_TUTORIAL
%
% Jesper Nielsen, Copyright (C) BMTWBM 2014

classdef (CaseInsensitiveProperties = true) fvg_sheet < fvg
    properties (Constant)
        Type = 'fvg_sheet'
    end
    properties
        Vectors = 'off'
        VectorObj
        ZOffset = 0
        Transparency = false
    end
    properties (Dependent)  % properties consistent with those in fvresObj
        Ref = 'sigma'
        Range = [0 1]
        BedRef = [];
        BedFrac = false;
    end
    properties (Hidden = true)
        variables_sheet
        face
    end
    
    methods
        % // constructor method //
        function obj = fvg_sheet(controlObj,resfil,varargin)
            % Pre-initialization — compute arguments for superclass constructor. Any code not using output argument (obj)
            h = fvres_sheet(resfil);
            
            % Object initialization — call superclass constructor before accessing object. You cannot conditionalize this statement
            obj@fvg(controlObj,resfil,h);
            
            % Post initialization — Operations related to the subclass, referencing and assigning to obj, calling class methods, passing onto functions etc.
            % -- update the patches to display the bathy
            TMP = netcdf_get_var(obj.ResObj.Nci(1),'names',{'cell_node','node_X','node_Y','cell_Zb'});
            vx = TMP.node_X;
            vy = TMP.node_Y;
            face = TMP.cell_node;
            i = find(face(:) == 0);
            face(i) = face(i-3);
            obj.face = reshape(face,4,[]);
            xdata = vx(obj.face);
            ydata = vy(obj.face);
            set(obj.PatchObj,'XData',xdata,'YData',ydata,'FaceColor','flat','CData',TMP.cell_Zb,'EdgeColor','none')
            
            % -- ensure initialise at correct time
            tmp = get(obj.ControlObj,'TimeCurrent');
            set(obj.ResObj,'TimeCurrent',tmp) % updatepatchdata won't do anything until a variable has been set
            
            % -- property / value pairs (optional inputs)
            noi = length(varargin);
            if mod(noi,2) ~= 0
                error('expecting optional inputs as property / value pairs')
            end
            for aa = 1:2:noi
                set(obj,varargin{aa},varargin{aa+1})
            end
        end
        % // set methods //
        function set.Ref(obj,val)
            set(obj.ResObj,'Ref',lower(val))
        end
        function set.Range(obj,val)
            set(obj.ResObj,'Range',val)
        end
        function set.BedRef(obj,val)
            set(obj.ResObj,'BedRef',val)
        end
        function set.BedFrac(obj,val)
            set(obj.ResObj,'BedFrac',val)
        end
        function set.Vectors(obj,val)
            switch lower(val)
                case 'on'
                    if isempty(obj.VectorObj)
                        obj.VectorObj = fvg_sheetvec(obj.ControlObj,obj.Resfil,'ResObj',obj.ResObj,'PeerObj',obj.PeerObj);
                        obj.VectorObj.ListObj_ut.Enabled = false;
                        obj.VectorObj.ListObj_up.Source = obj.ListObj_up.Source;
                        obj.VectorObj.TitleTime = 'off';
                        tmp = union(obj.Variables,{'V_x';'V_y'});
                        set(obj.ResObj,'Variables',tmp)
                    end
                case 'off'
                    if ~isempty(obj.VectorObj)
                        delete(obj.VectorObj)
                        obj.VectorObj = [];
                        var = get(obj,'Variables'); % remove V_x & V_y from resObj
                        set(obj.ResObj,'Variables',var)
                    end
                otherwise
                    error('unrecognised input for property "vectors"')
            end
            obj.Vectors = val;
        end
        function set.ZOffset(obj,val)
            if isscalar(val)
                obj.ZOffset = val;
                tmp = get(obj.PatchObj,'XData');
                tmp(:) = val;
                set(obj.PatchObj,'ZData',tmp) % this means ZData is not set everytime updatepatchdata is called
            else
                error('expecting scalar value for property vec_elevation')
            end
        end
        function set.Transparency(obj,val)
            if islogical(val)
                obj.Transparency = val;
                if val
                    if strcmpi(obj.FaceColor,'flat')
                        display('FaceColor of flat is not supported when mapping Transparency - changed to interp')
                        set(obj,'FaceColor','interp')
                    else
                        set(obj.ResObj,'OutputType','node')
                    end
                else
                    set(obj.PatchObj,'FaceAlpha',1)
                end
            else
                error('expecting logical value for Transparency')
            end
        end
        % // get methods //
        function val = get.Ref(obj)
            val = get(obj.ResObj,'Ref');
        end
        function val = get.Range(obj)
            val = get(obj.ResObj,'Range');
        end
        function val = get.BedRef(obj)
            val = get(obj.ResObj,'BedRef');
        end
        function val = get.BedFrac(obj)
            val = get(obj.ResObj,'BedFrac');
        end
        
        % // update patches //
        function updatepatchdata(obj)
            vars = fieldnames(obj.ResObj.ResultsCell); % fv_get_sheet can create vaiables when ~isempty(bedref). Customized variable names are also used for customized results
            vars = setxor(vars,'stat');
            if ~isempty(vars)
                switch obj.ResObj.OutputType
                    case 'cell'
                        r_name = 'ResultsCell';
                    case 'node'
                        r_name = 'ResultsNode';
                end
                % -- magnitude of vector variables
                if length(vars) == 2
                    tmp = hypot(obj.ResObj.(r_name).(vars{1}),obj.ResObj.(r_name).(vars{2})); % no functionality for visualising contoured current directions - use vectors or expression property
                else
                    tmp = obj.ResObj.(r_name).(vars{1});
                end
                % -- update colors &/| transparency
                switch r_name
                    case 'ResultsCell'
                        set(obj.PatchObj,'CData',tmp)
                    case 'ResultsNode'
                        cdata = tmp(obj.face);
                        i = isnan(obj.ResObj.ResultsCell.(vars{1})); % cells which are dry and/or outside the depth averaging limits
                        cdata(:,i) = NaN;
                        if strcmpi(obj.FaceColor,'interp')
                            set(obj.PatchObj,'CData',cdata)
                        end
                        if obj.Transparency
                            set(obj.PatchObj,'FaceVertexAlphaData',cdata(:))
                            set(obj.PatchObj,'FaceAlpha','interp') % this should be taken outside of updatepatchdata
                        end
                end
                
                if strcmp(obj.TitleTime,'on')
                    tstr = datestr(obj.ResObj.TimeCurrent,'dd-mmm-yyyy HH:MM:SS');
                    set(get(obj.PeerObj,'title'),'string',tstr)
                end
            end
        end
    end
end
% // subfunctions //
